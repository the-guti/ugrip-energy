from typing import Tuple
import gym
import numpy as np
from gym.core import ActType, ObsType
from simulation import Simulation


class Environment(gym.Env):
    """
    Wraps the simulation as a `gym` environment, so it can be easily used for RL.

    Args:
        dataset (pandas.DataFrame): The dataset which is used for the simulation.
        The dataset must contain the following columns:
            - `load`: The electricity load in kWh.
            - `solar`: The solar generation in kWh.
            - `wind`: The wind generation in kWh.
            - `price`: The price at which electricity is bought from the grid in $/kWh.
            - `month`: The month of the year.
            - `day_type`: The type of the day (weekday - 1, weekend - 0).
            - `hour`: The hour of the day.
        num_forecasting_steps (int): The number of timesteps into the future included in
            the forecast. Note that the forecast is noisy.
        solar_power_installed (float): The installed peak photovoltaic power in kWp.
        wind_power_installed (float): The installed peak wind power in kWp.
        battery_capacity (float): The capacity of the battery in kWh.
        initial_state_of_charge (float): The initial state of charge of the battery in kWh.
        max_battery_charge_per_timestep (float): Maximum amount of energy (kWh) which can
            be obtained from / used to charge the battery in one time step.
        sell_back_price_rate (float): The rate at which excess energy generated by the
            building can be sold back to the grid or external sources. This parameter
            determines the financial incentive for the building to sell its excess energy,
            and affects the optimization of energy storage and consumption.
        noise_influence (float): The influence of the noise on the forecast.
        emissions_per_kwh (float): The emissions per kWh of the external generator.
        lambda_co2 (float): The weight given to the CO2 emissions in the reward function.
            It represents the trade-off between minimizing CO2 emissions and minimizing
            energy cost. The value should be between 0 and 1, where 0 means only
            considering energy cost in the reward function and 1 means only considering
            CO2 emissions in the reward function.
    """

    def __init__(
        self,
        dataset,
        num_forecasting_steps,
        battery_capacity,
        initial_state_of_charge,
        solar_power_installed,
        wind_power_installed,
        max_battery_charge_per_timestep,
        sell_back_price_rate,
        noise_influence,
        emissions_per_kwh,
        lambda_co2,
    ):

        self.simulation = Simulation(
            dataset=dataset,
            battery_capacity=battery_capacity,
            initial_state_of_charge=initial_state_of_charge,
            solar_power_installed=solar_power_installed,
            wind_power_installed=wind_power_installed,
            max_battery_charge_per_timestep=max_battery_charge_per_timestep,
            sell_back_price_rate=sell_back_price_rate,
        )
        self.max_battery_charge_per_timestep = max_battery_charge_per_timestep
        # the simulation will run for the length of the dataset minus
        # the number of forecasting steps minus one
        num_rows = len(self.simulation.electricity_load_profile)
        self.max_timesteps = num_rows - num_forecasting_steps - 1
        self.num_forecasting_steps = num_forecasting_steps
        self.noise_influence = noise_influence
        self.emissions_per_kwh = emissions_per_kwh
        self.lambda_co2 = lambda_co2
        self.action_space = gym.spaces.box.Box(
            low=-1, high=1, shape=(1,), dtype=np.float32
        )
        self.observation_space = gym.spaces.box.Box(
            shape=(self.num_forecasting_steps * 4 + 4,),
            low=-np.inf,
            high=np.inf,
            dtype=np.float32,
        )
        pass

    def reset(self) -> Tuple[ObsType, dict]:
        """
        Resets the state of the simulation by calling the `reset()` from the simulation.

        Returns:
            Tuple of:
                1. An observation.
                2. Empty hashmap: {}
        """

        self.simulation.reset()
        return self.get_observation(), {}

    def step(self, action: ActType) -> Tuple[ObsType, float, bool, bool, dict]:
        """
        Performs one step, which is done by:

        1. Performing one `simulate_one_step()`.
        2. Calculating the reward.
        3. Retrieving the observation.

        Args:
            action (float): Fraction of energy to be stored or retrieved from the battery.
                The action lies in [-1;1]. The action represents the fraction of
                `max_battery_charge_per_timestep` which should be used to charge or
                discharge the battery. 1 represents the maximum possible amount of energy
                which can be used to charge the battery per time step.
        Returns:
            Tuple of:
                1. observation.
                2. reward.
                3. terminated. If true, the episode is over.
                4. truncated. Is always false, it is not implemented yet.
                5. Additional info about the `electricity_comsumption`, the `excess_energy`,
                    and the `cost_of_external_generator` of the current time step.
        """

        if hasattr(action, "__len__"):
            action = action[0]
        (
            electricity_consumption,
            excess_energy,
            cost_of_external_generator,
            revenue_from_excess_energy,
        ) = self.simulation.simulate_one_step(
            action * self.max_battery_charge_per_timestep
        )
        reward = self.calc_reward(
            cost_of_external_generator,
            revenue_from_excess_energy,
            electricity_consumption,
        )
        # observation = self.get_observation()
        return (
            # observation,
            reward,
            self.get_terminated(),
            False,
            {
                "electricity_consumption": electricity_consumption,
                "excess_energy": excess_energy,
                "cost_of_external_generator": cost_of_external_generator,
            },
        )

    def get_terminated(self):
        """
        Returns true if the simulation is terminated, false otherwise.
        """
        if self.simulation.step_count > self.max_timesteps:
            return True
        return False

    def get_observation(self):
        """
        Generates an observation that includes the current state of charge of the battery,
        month, day type, hour and the forecasted noisy electricity load, solar generation, wind
        generation, and external generation cost for the next `num_forecasting_steps`.
        """
        current_index = self.simulation.start_index + self.simulation.step_count

        # Get the current month, day type and hour
        current_month = self.simulation.months[current_index]
        current_day_type = self.simulation.day_types[current_index]
        current_hour = self.simulation.hours[current_index]

        # Get the forecast for the next `num_forecasting_steps` steps
        electric_load_forecast = self.simulation.electricity_load_profile[
            current_index : current_index + self.num_forecasting_steps
        ]
        solar_gen_forecast = self.simulation.solar_generation_profile[
            current_index : current_index + self.num_forecasting_steps
        ]
        wind_gen_forecast = self.simulation.wind_generation_profile[
            current_index : current_index + self.num_forecasting_steps
        ]
        external_gen_cost_forecast = self.simulation.external_generation_profile[
            current_index : current_index + self.num_forecasting_steps
        ]

        # Calculate the standard deviations
        solar_gen_std = np.std(self.simulation.solar_generation_profile)
        wind_gen_std = np.std(self.simulation.wind_generation_profile)
        electric_load_std = np.std(self.simulation.electricity_load_profile)

        # Generate noise with scaling factor that increases with the forecast days
        noise_scaling_factor = (
            np.array(range(1, self.num_forecasting_steps + 1)) * self.noise_influence
        )
        solar_gen_noise = (
            np.random.normal(0, solar_gen_std, self.num_forecasting_steps)
            * noise_scaling_factor
        )
        wind_gen_noise = (
            np.random.normal(0, wind_gen_std, self.num_forecasting_steps)
            * noise_scaling_factor
        )
        electric_load_noise = (
            np.random.normal(0, electric_load_std, self.num_forecasting_steps)
            * noise_scaling_factor
        )

        # Add noise to the forecast values
        electric_load_forecast_noisy = electric_load_forecast + electric_load_noise
        solar_gen_forecast_noisy = solar_gen_forecast + solar_gen_noise
        wind_gen_forecast_noisy = wind_gen_forecast + wind_gen_noise

        return np.concatenate(
            (
                [self.simulation.building.battery.state_of_charge],
                [current_month],
                [current_day_type],
                [current_hour],
                electric_load_forecast_noisy,
                solar_gen_forecast_noisy,
                wind_gen_forecast_noisy,
                external_gen_cost_forecast,
            ),
            axis=0,
        )

    def calc_reward(
        self,
        cost_of_external_generator,
        revenue_from_excess_energy,
        electricity_consumption,
    ):
        """
        Calculates the reward for the current time step.
        """
        return (
            #!
            # - self.lambda_co2 * (cost_of_external_generator - revenue_from_excess_energy)
            # - (1 - self.lambda_co2) * electricity_consumption * self.emissions_per_kwh
            (cost_of_external_generator - revenue_from_excess_energy)
        )
